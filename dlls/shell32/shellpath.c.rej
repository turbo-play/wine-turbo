--- dlls/shell32/shellpath.c
+++ dlls/shell32/shellpath.c
@@ -2640,6 +2640,183 @@ end:
     return hr;
 }
 
+static char *xdg_config;
+static DWORD xdg_config_len;
+
+static BOOL WINAPI init_xdg_dirs( INIT_ONCE *once, void *param, void **context )
+{
+    const WCHAR *var, *fmt = L"\\??\\unix%s/user-dirs.dirs";
+    char *p;
+    WCHAR *name, *ptr;
+    HANDLE file;
+    DWORD len;
+
+    if (!(var = _wgetenv( L"XDG_CONFIG_HOME" )) || var[0] != '/')
+    {
+        if (!(var = _wgetenv( L"WINEHOMEDIR" ))) return TRUE;
+        fmt = L"%s/.config/user-dirs.dirs";
+    }
+    len = lstrlenW(var) + lstrlenW(fmt);
+    name = heap_alloc( len * sizeof(WCHAR) );
+    swprintf( name, len, fmt, var );
+    name[1] = '\\';  /* change \??\ to \\?\ */
+    for (ptr = name; *ptr; ptr++) if (*ptr == '/') *ptr = '\\';
+
+    file = CreateFileW( name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0 );
+    heap_free( name );
+    if (file != INVALID_HANDLE_VALUE)
+    {
+        len = GetFileSize( file, NULL );
+        if (!(xdg_config = heap_alloc( len + 1 ))) return TRUE;
+        if (!ReadFile( file, xdg_config, len, &xdg_config_len, NULL ))
+        {
+            heap_free( xdg_config );
+            xdg_config = NULL;
+        }
+        else
+        {
+            for (p = xdg_config; p < xdg_config + xdg_config_len; p++) if (*p == '\n') *p = 0;
+            *p = 0;  /* append null to simplify string parsing */
+        }
+        CloseHandle( file );
+    }
+    return TRUE;
+}
+
+static char *get_xdg_path( const char *var )
+{
+    static INIT_ONCE once;
+    char *p, *ret = NULL;
+    int i;
+
+    InitOnceExecuteOnce( &once, init_xdg_dirs, NULL, NULL );
+    if (!xdg_config) return NULL;
+
+    for (p = xdg_config; p < xdg_config + xdg_config_len; p += strlen(p) + 1)
+    {
+        while (*p == ' ' || *p == '\t') p++;
+        if (strncmp( p, var, strlen(var) )) continue;
+        p += strlen(var);
+        while (*p == ' ' || *p == '\t') p++;
+        if (*p != '=') continue;
+        p++;
+        while (*p == ' ' || *p == '\t') p++;
+        if (*p != '"') continue;
+        p++;
+        if (*p != '/' && strncmp( p, "$HOME/", 6 )) continue;
+
+        if (!(ret = heap_alloc( strlen(p) + 1 ))) break;
+        for (i = 0; *p && *p != '"'; i++, p++)
+        {
+            if (*p == '\\' && p[1]) p++;
+            ret[i] = *p;
+        }
+        ret[i] = 0;
+        if (*p != '"')
+        {
+            heap_free( ret );
+            ret = NULL;
+        }
+        break;
+    }
+    return ret;
+}
+
+static BOOL link_folder( HANDLE mgr, const UNICODE_STRING *path, const char *link )
+{
+    struct mountmgr_shell_folder *ioctl;
+    DWORD len = sizeof(*ioctl) + path->Length + strlen(link) + 1;
+    BOOL ret;
+
+    if (!(ioctl = heap_alloc( len ))) return FALSE;
+    ioctl->create_backup = FALSE;
+    ioctl->folder_offset = sizeof(*ioctl);
+    ioctl->folder_size = path->Length;
+    memcpy( (char *)ioctl + ioctl->folder_offset, path->Buffer, ioctl->folder_size );
+    ioctl->symlink_offset = ioctl->folder_offset + ioctl->folder_size;
+    strcpy( (char *)ioctl + ioctl->symlink_offset, link );
+
+    ret = DeviceIoControl( mgr, IOCTL_MOUNTMGR_DEFINE_SHELL_FOLDER, ioctl, len, NULL, 0, NULL, NULL );
+    heap_free( ioctl );
+    return ret;
+}
+
+/******************************************************************************
+ * create_link
+ *
+ * Sets up a symbolic link for one of the 'My Whatever' shell folders to point
+ * into the corresponding XDG directory.
+ */
+static void create_link( const WCHAR *path, const char *xdg_name, const char *default_name )
+{
+    UNICODE_STRING nt_name;
+    char *target = NULL;
+    HANDLE mgr;
+
+    if ((mgr = CreateFileW( MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
+                            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
+                            0, 0 )) == INVALID_HANDLE_VALUE)
+    {
+        FIXME( "failed to connect to mount manager\n" );
+        return;
+    }
+
+    nt_name.Buffer = NULL;
+    if (!RtlDosPathNameToNtPathName_U( path, &nt_name, NULL, NULL )) goto done;
+
+    if ((target = get_xdg_path( xdg_name )))
+    {
+        if (link_folder( mgr, &nt_name, target )) goto done;
+    }
+    if (link_folder( mgr, &nt_name, default_name )) goto done;
+
+    /* fall back to HOME */
+    link_folder( mgr, &nt_name, "$HOME" );
+
+done:
+    RtlFreeUnicodeString( &nt_name );
+    heap_free( target );
+    CloseHandle( mgr );
+}
+
+/******************************************************************************
+ * _SHCreateSymbolicLink  [Internal]
+ *
+ * Sets up a symbolic link for one of the special shell folders to point into
+ * the users home directory.
+ *
+ * PARAMS
+ *  nFolder [I] CSIDL identifying the folder.
+ */
+static void _SHCreateSymbolicLink(int nFolder, const WCHAR *path)
+{
+    DWORD folder = nFolder & CSIDL_FOLDER_MASK;
+
+    switch (folder) {
+        case CSIDL_PERSONAL:
+            create_link( path, "XDG_DOCUMENTS_DIR", "$HOME/Documents" );
+            break;
+        case CSIDL_DESKTOPDIRECTORY:
+            create_link( path, "XDG_DESKTOP_DIR", "$HOME/Desktop" );
+            break;
+        case CSIDL_MYPICTURES:
+            create_link( path, "XDG_PICTURES_DIR", "$HOME/Pictures" );
+            break;
+        case CSIDL_MYVIDEO:
+            create_link( path, "XDG_VIDEOS_DIR", "$HOME/Movies" );
+            break;
+        case CSIDL_MYMUSIC:
+            create_link( path, "XDG_MUSIC_DIR", "$HOME/Music" );
+            break;
+        case CSIDL_DOWNLOADS:
+            create_link( path, "XDG_DOWNLOAD_DIR", "$HOME/Downloads" );
+            break;
+        case CSIDL_TEMPLATES:
+            create_link( path, "XDG_TEMPLATES_DIR", "$HOME/Templates" );
+            break;
+    }
+}
+
 /******************************************************************************
  * SHGetFolderPathW			[SHELL32.@]
  *
@@ -2828,6 +3005,10 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
         goto end;
     }
 
+    /* create symbolic links rather than directories for specific
+     * user shell folders */
+    _SHCreateSymbolicLink(folder, szBuildPath);
+
     /* create directory/directories */
     ret = SHCreateDirectoryExW(hwndOwner, szBuildPath, NULL);
     if (ret && ret != ERROR_ALREADY_EXISTS)
